import http from 'http';
import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import axios from 'axios';
import { WebSocketServer } from 'ws';
import { 
  PORT, 
  BOT_TOKEN, 
  SUPERGROUP_ID, 
  WEBHOOK_SECRET, 
  allowedOrigins,
  lovableSandboxRegex,
  sb,
  sbAuth,
  SUPABASE_URL,
  SUPABASE_SERVICE_ROLE,
  SUPABASE_ANON_KEY
} from './src/config/env.js';
import snapTalkRoutes from './src/routes/snapTalkClients.js';
import widgetRoutes from './src/routes/widgets.js';
import adminRoutes from './src/routes/adminRoutes.js';

import { apiKeys, loadActiveClientsToApiKeys, updateClientInApiKeys } from './src/routes/snapTalkClients.js';
import telegramRoutes, { setPushToClient } from './src/routes/telegram.js';
import { supabaseDB } from './src/config/supabase.js';
import { 
  findClientByApiKey,
  ensureTopicForVisitor,
  ensureTopic, 
  sendToTopic,
  sendTelegramMessage,
  saveSiteVisit,
  memoryMap
} from './src/services/telegramService.js';

const app = express();

// CORS: —Ä–∞–∑—Ä–µ—à–∞–µ–º SnapTalk —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ –∏ *.lovable.app
app.use(cors({
  origin: (origin, cb) => {
    // –†–∞–∑—Ä–µ—à–∞–µ–º –∑–∞–ø—Ä–æ—Å—ã –±–µ–∑ origin (health checks, Postman, Telegram webhook)
    if (!origin) return cb(null, true);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ—á–Ω—ã–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è
    if (allowedOrigins.includes(origin)) return cb(null, true);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—â–∏–µ –¥–æ–º–µ–Ω—ã lovable.app
    if (/\.lovable\.app$/i.test(origin)) return cb(null, true);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º Lovable sandbox –¥–æ–º–µ–Ω—ã
    if (lovableSandboxRegex.test(origin)) return cb(null, true);
    
    console.log('‚ùå CORS rejected origin:', origin);
    return cb(new Error('Not allowed by CORS'));
  },
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
}));
app.options('*', cors());

app.use(bodyParser.json({ limit: '1mb' }));

// ===== –ú–∞—Ä—à—Ä—É—Ç—ã API =====
app.use('/api/snaptalk', snapTalkRoutes);
app.use('/api', widgetRoutes);
app.use('/api', adminRoutes);




// ===== –û—Å–Ω–æ–≤–Ω—ã–µ —Ä—É—Ç—ã =====
app.get('/health', (_req, res) => res.json({ ok: true, ts: Date.now() }));
app.get('/favicon.ico', (_req, res) => res.sendStatus(204));



// ===== API: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ç—Ä–µ–∫–∏–Ω–≥ –≤–∏–∑–∏—Ç–æ–≤ =====
app.post('/api/visit/track', async (req, res) => {
  try {
    const { clientId, apiKey, visitorId, requestId, url, meta } = req.body || {};
    
    if (!clientId || !visitorId || !url) {
      return res.status(400).json({ ok: false, error: 'clientId, visitorId and url required' });
    }

    // –ù–∞—Ö–æ–¥–∏–º –∫–ª–∏–µ–Ω—Ç–∞ –ø–æ API –∫–ª—é—á—É
    const client = await findClientByApiKey(apiKey);
    if (!client) {
      console.log(`‚ùå Client not found for apiKey: ${apiKey}`);
      return res.status(404).json({ ok: false, error: 'Client not found' });
    }

    // üìä –í–°–ï–ì–î–ê –∑–∞–ø–∏—Å—ã–≤–∞–µ–º –≤–∏–∑–∏—Ç –≤ site_visits (–±–µ–∑ cooldown –¥–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–π –∞–Ω–∞–ª–∏—Ç–∏–∫–∏)
    const userAgent = req.headers['user-agent'] || null;
    const ipAddress = req.ip || req.connection.remoteAddress || null;
    await saveSiteVisit(clientId, visitorId, requestId, url, meta, userAgent, ipAddress);

    // üîÑ –ü—Ä–æ–≤–µ—Ä—è–µ–º cooldown —Ç–æ–ª—å–∫–æ –¥–ª—è Telegram —Ç–æ–ø–∏–∫–æ–≤ (30 –º–∏–Ω—É—Ç)
    const recentVisit = await checkRecentVisit(clientId, visitorId, url);
    if (recentVisit) {
      return res.json({ ok: true, message: 'Visit tracked in site_visits, Telegram skipped (recent)' });
    }

    // ‚úÖ –î–∞–Ω–Ω—ã–µ —Ç–∞–∫–∂–µ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ client_topics —á–µ—Ä–µ–∑ ensureTopicForVisitor ‚Üí dbSaveTopic

    // –°–æ–∑–¥–∞–µ–º/–Ω–∞—Ö–æ–¥–∏–º —Ç–æ–ø–∏–∫ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram  
    const topicResult = await ensureTopicForVisitor(clientId, client, visitorId, requestId, url, meta);
    const { topicId, isExistingVisitor, previousUrl, firstVisit } = 
      typeof topicResult === 'object' ? topicResult : { topicId: topicResult, isExistingVisitor: false };
    
    // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å—Ç–∞—Ç—É—Å–∞ –ø–æ—Å–µ—Ç–∏—Ç–µ–ª—è
    let message, prefix;
    if (isExistingVisitor) {
      message = formatReturnVisitMessage(client, visitorId, url, meta, previousUrl, firstVisit);
      prefix = `üîÑ –ü–û–í–¢–û–†–ù–´–ô –í–ò–ó–ò–¢\n\n`;
    } else {
      message = formatVisitMessage(client, visitorId, url, meta);
      prefix = `üë§ –ù–û–í–´–ô –ü–û–°–ï–¢–ò–¢–ï–õ–¨\n\n`;
    }
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ —É–∂–µ –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω—ã–π —Ç–æ–ø–∏–∫
    await sendTelegramMessage(topicId, message, prefix, client);

    const statusText = isExistingVisitor ? 'Return visitor' : 'New visitor';
    console.log(`üë§ ${statusText} tracked: ${client.client_name} ‚Üí ${url} [${visitorId.slice(0,8)}...] Topic: ${topicId}`);
    return res.json({ ok: true });

  } catch (e) {
    console.error('Visit tracking error:', e);
    return res.status(500).json({ ok: false, error: String(e.message || e) });
  }
});



// ===== API: —Å–∞–π—Ç -> Telegram =====
app.post('/api/chat/send', async (req, res) => {
  try {
    const { clientId, apiKey, text, meta, visitorId, requestId } = req.body || {};
    if (!clientId || !text) {
      return res.status(400).json({ ok: false, error: 'clientId and text required' });
    }

    // –ù–∞—Ö–æ–¥–∏–º –∫–ª–∏–µ–Ω—Ç–∞ –ø–æ API –∫–ª—é—á—É
    const client = await findClientByApiKey(apiKey);
    if (!client) {
      console.log(`‚ùå Client not found for apiKey: ${apiKey}`);
      return res.status(404).json({ ok: false, error: 'Client not found' });
    }

    const utm = meta?.utm || {};
    const ref = meta?.ref || '';
    const prefixParts = [
      `#${clientId}`,
      utm.source ? `${utm.source}` : null,
      utm.campaign ? `${utm.campaign}` : null,
      utm.term ? `${utm.term}` : null,
      ref ? `ref:${ref}` : null,
    ].filter(Boolean);
    const prefix = prefixParts.length ? `${prefixParts.join(' / ')}\n\n` : `#${clientId}\n\n`;

    console.log(`üí¨ Site ‚Üí Telegram: "${text}" ‚Üí ${clientId} (${client.client_name})${visitorId ? ` [Visitor: ${visitorId.slice(0,8)}...]` : ''}`);
    await sendToTopic({ clientId, text, prefix, client, visitorId, requestId });
    return res.json({ ok: true });
  } catch (e) {
    console.error(e);
    return res.status(500).json({ ok: false, error: String(e.message || e) });
  }
});

// –ü–æ–¥–∫–ª—é—á–∞–µ–º Telegram —Ä–æ—É—Ç–µ—Ä
app.use('/telegram', telegramRoutes);

// ===== HTTP+WS —Å–µ—Ä–≤–µ—Ä –∏ WS-—Ö–∞–± =====
const server = http.createServer(app);
const wss = new WebSocketServer({ server, path: '/ws' });

// clientId -> Set<WebSocket>
const hub = new Map();

wss.on('connection', (ws, req) => {
  try {
    const url = new URL(req.url, 'http://localhost'); // path –∏ query
    const clientId = url.searchParams.get('clientId');
    if (!clientId) { ws.close(1008, 'clientId required'); return; }

    let set = hub.get(clientId);
    if (!set) { set = new Set(); hub.set(clientId, set); }
    set.add(ws);

    ws.on('close', () => {
      const s = hub.get(clientId);
      if (!s) return;
      s.delete(ws);
      if (!s.size) hub.delete(clientId);
    });
  } catch {
    try { ws.close(); } catch {}
  }
});

// ===== –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ç—Ä–µ–∫–∏–Ω–≥–∞ –≤–∏–∑–∏—Ç–æ–≤ =====
// üîÑ –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ–¥–∞–≤–Ω–∏—Ö –≤–∏–∑–∏—Ç–æ–≤ —á–µ—Ä–µ–∑ client_topics (–ù–ï site_visits!)
async function checkRecentVisit(clientId, visitorId, url) {
  if (!sb || !visitorId) return false; // –í memory mode –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥—É–±–ª–∏
  
  const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000).toISOString();
  
  try {
    const { data, error } = await sb
      .from('client_topics')
      .select('updated_at, page_url')
      .eq('client_id', clientId)
      .eq('visitor_id', visitorId)
      .gte('updated_at', thirtyMinutesAgo)
      .maybeSingle();
      
    if (error) {
      console.error('‚ùå checkRecentVisit error:', error);
      return false;
    }
    
    // –ï—Å–ª–∏ –µ—Å—Ç—å –Ω–µ–¥–∞–≤–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ–º—ã –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ—Å–µ—Ç–∏—Ç–µ–ª—è
    const hasRecentActivity = !!data;
    if (hasRecentActivity) {
      console.log(`‚è∞ Recent activity found for visitor ${visitorId.slice(0,8)}... (within 30 min)`);
    }
    
    return hasRecentActivity;
  } catch (error) {
    console.error('‚ùå checkRecentVisit error:', error);
    return false;
  }
}

// ‚ùå –£–î–ê–õ–ï–ù–ê: saveVisitToDatabase - –¥–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ client_topics —á–µ—Ä–µ–∑ dbSaveTopic

function formatVisitMessage(client, visitorId, url, meta) {
  const timestamp = new Date().toLocaleString('ru-RU', {
    timeZone: 'Europe/Moscow',
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });

  let message = `${url}\n`;
  message += `Visitor ID: ${visitorId}\n`;
  message += `${meta?.title || ''}\n\n`;
  message += `${timestamp}\n\n`;
  
  return message;
}

// üÜï –§–æ—Ä–º–∞—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –≤–∏–∑–∏—Ç–∞
function formatReturnVisitMessage(client, visitorId, url, meta, previousUrl, firstVisit) {
  const timestamp = new Date().toLocaleString('ru-RU', {
    timeZone: 'Europe/Moscow',
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });

  let message = `${url}\n`;
  message += `Visitor ID: ${visitorId}\n`;
  message += `${meta?.title || ''}\n\n`;
  message += `${timestamp}\n\n`;
  
  return message;
}



function pushToClient(clientId, payload) {
  const set = hub.get(clientId);
  if (!set || !set.size) return;
  
  const data = JSON.stringify(payload);
  for (const ws of set) {
    try { 
      ws.send(data); 
    } catch (error) {
      console.error('‚ùå WebSocket send failed:', error);
    }
  }
}

// –ü–µ—Ä–µ–¥–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é pushToClient –≤ Telegram —Ä–æ—É—Ç–µ—Ä
setPushToClient(pushToClient);

// –°—Ç–∞—Ä—Ç
server.listen(PORT, async () => {
  console.log('üöÄ SnapTalk Server listening on port', PORT);
  console.log('üîß Environment check:');
  console.log('  - BOT_TOKEN:', BOT_TOKEN ? 'SET' : 'NOT SET');
  console.log('  - SUPERGROUP_ID:', SUPERGROUP_ID || 'NOT SET');
  console.log('  - WEBHOOK_SECRET:', WEBHOOK_SECRET || 'NOT SET');
  console.log('  - SUPABASE_URL:', SUPABASE_URL ? 'SET' : 'NOT SET');
  console.log('  - SUPABASE_SERVICE_ROLE:', SUPABASE_SERVICE_ROLE ? 'SET' : 'NOT SET');
  console.log('  - SUPABASE_ANON_KEY:', SUPABASE_ANON_KEY ? 'SET' : 'NOT SET');
  console.log('üì° Webhook URL: /telegram/webhook/' + WEBHOOK_SECRET);
  console.log('üéØ SnapTalk Frontend integration:', sbAuth ? 'ENABLED' : 'DISABLED');
  console.log('üîó CORS allowed origins:', allowedOrigins.join(', '));
  
  // –ó–∞–≥—Ä—É–∂–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –∫–ª–∏–µ–Ω—Ç—ã –≤ apiKeys
  await loadActiveClientsToApiKeys();
});
